# Authorization

> 얄팍한 코딩사전 중 [세션 VS. 토큰! JWT가 뭔가요?](https://www.youtube.com/watch?v=1QiOXWEbqYQ)를 보고 내용 정리

로그인은 일반인 관점에서 봤을 때 쉬워보여도 보안에도 직결되고 사용자들이 불편하지 않아야해서 직접 개발하려고 하면 고려해야할 것이 많다.
ex. 이메일, 비밀번호를 그대로 데이터베이스에 저장해두는 경우 데이터베이스가 뚫리면 모두 유출된다.

로그인도 어렵지만 로그인 상태가 유지되게 하는 것도 만만찮게 까다롭다. -> 로그인을 할 경우 로그인이 돼 있다는 걸 서버가 알고 있어야 한다.
ex. gmail에 로그인했는데 받은 편지함에 들어갈 때 마다 일일이 다시 로그인해야 한다면 아주 불편하다.

=> 실제로 서버를 프로그래밍할 때 인증과 인가를 어떻게 할지가 중요한 이슈

**인증(Authentication)**: 사이트에 가입된 회원임을, 즉 특정 서비스에 일정 권한이 주어진 사용자임을 아이디와 패스워드 등을 통해서 인증받는 것 -> 쉽게말해 로그인하는 과정

사용자가 자기 계정을 사용하려고 할 때 로그인 시키는 것

**인가(Authorization)**: 한 번 인증을 받은 사용자가 이후 서비스의 여러 기능들을 사용할 때 (페이스북에서 친구들의 목록을 보거나 담벼락에 글을 작성, 게시물에 좋아요나 댓글을 다는 등 내 계정으로**만** 할 수 있는 활동을 시도할 때 내가 로그인 되어있음을 알아보고 허가를 해주는 것) -> 로그인이 유지되는 상태에서 일어나는 일

인증을 받은 사용자가 서비스 안에서 돌아다닐 때 서버가 로그인 한 사용자라는 걸 알아보고 허가해주는 것

어떤 사이트나 서비스에서 사용자가 로그인해있다는 사실을 서버가 인지할 수 있도록 하는 방법

특정 사이트의 서버는 동시다발적으로 들어오는 무수한 요청에 응답하고 있다.
서버는 각 요청이 들어올 때마다 요청을 보낸 사용자가 인증과정을 거친 상태인지 확인을 해서 그에 따라 로그인이 필요한 기능들에 허용을 해줄지 말지를 결정해서 응답한다.

아이디, 비밀번호를 브라우저에 저장해두고 매 요청마다 다시 로그인을 하면 어떨까?
로그인은 꽤 무거운 작업이다.
데이터베이스에 저장된 사용자 계정의 해시값 등을 꺼내온 다음 사용자의 암호를 복잡한 알고리즘으로 계산한 값과 일치하는지 확인하는 과정을 거쳐야한다. -> 계산도 힘들고 데이터베이스에 접근하는 것 자체가 시간과 자원을 많이 잡아먹는 일
요청마다 아이디와 패스워드가 실려가는 것 자체도 보안상 위험하다.

### 세션

- 전통적으로 많이 사용되어온 방식
- 사용자가 로그인에 성공하면 서버는 세션을 출력해서 반쪽을 브라우저에 보내고 다른 반쪽은 서버의 메모리에 보관한다. (경우에 따라 하드디스크, 데이터베이스에 보관) (메모리 > 하드디스크 > 데이터베이스 순으로 속도가 빠르다.)
- 브라우저는 서버로 전달받은 세션을 `Session ID`란 이름으로 쿠키에 저장하고 다음 요청을 보낼 때 마다 세션을 같이 전달한다.
- 서버는 요청과 함께 온 세션을 자신이 가지고 있는 세션과 짝이 맞는지 확인해서 인가를 해준다.
- 세션: Session ID를 이용해서 사용자의 서버 로그인이 지속되는 상태
  -> 서버에서 어떤 사용자들이 현재 로그인해있는지를 세션을 통해 기억해두고 있는것
- 단점: 사용자가 동시에 많이 접속하면 메모리가 부족해진다.
  문제가 생겨서 서버가 재부팅된다면 메모리는 초기화된다.
  사용자는 로그인상태가 풀리게 되고 다시 로그인해야한다.
  하드디스크다 데이터베이스에 보관하게되면 속도가 느리다.
  서버를 여러대 두고 사이트를 운영할 때 문제가 생긴다.
  - 서버는 각자 메모리를 가지고 있어서 로드밸런싱 기능으로 사용자의 요청을 분산시키는데 인증은 1번 서버에서 기능 요청은 3번 서버에서 한다면 세션을 유지하기가 까다로워진다.
    (데이터베이스 서버를 활용하거나(속도 느림), 레디스나 MemCached 같은 메모리형 데이터베이스 서버(공용 메모리)에 세션을 보관하기도 한다.)
