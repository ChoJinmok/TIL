# Authorization

> 얄팍한 코딩사전 중 [세션 VS. 토큰! JWT가 뭔가요?](https://www.youtube.com/watch?v=1QiOXWEbqYQ)를 보고 내용 정리

## 1. 인증, 인가

### 1.1. 인증 (Authentication)

**인증(Authentication)**: 사이트에 가입된 회원임을, 즉 특정 서비스에 일정 권한이 주어진 사용자임을 아이디와 패스워드 등을 통해서 인증받는 것 -> 사용자가 자신의 계정을 사용하려고 하면 로그인 시키는 과정

로그인은 일반인 관점에서 봤을 때 쉬워보여이는 기능이지만 보안에도 직결되고 사용자들의 편의까지 고려해야해서 고려해야할 것이 많은 기능이다. (ex. 이메일, 비밀번호를 그대로 데이터베이스에 저장해두는 경우 데이터베이스가 뚫리면 모두 유출된다.)

### 1.2. 인가 (Authorization)

**인가(Authorization)**: 한 번 인증을 받은 사용자가 이후 서비스의 여러 기능들을 사용할 때 내 계정으로**만** 할 수 있는 활동(ex. 친구 목록을 보는 일, 글을 작성, 게시물에 좋아요나 댓글을 다는 일)을 시도할 때 내가 로그인 되어있음을 알아보고 허가를 해주는 것  
-> 어떤 사이트나 서비스에서 인증을 받은(로그인 한) 사용자가 서비스 안에서 돌아다닐 때 <U>서버가 로그인 한 사용자라는 걸 인지하도록 하는 방법</U>이 포인트

로그인 상태가 유지되게 하는 것도 만만찮게 까다롭다. -> 로그인을 유지시키려면 로그인이 돼 있다는 걸 서버가 알고 있어야 한다. (ex. gmail에 로그인했는데 받은 편지함에 들어갈 때 마다 일일이 다시 로그인해야 한다면 아주 불편하다.)

## 2. How to Authorize?

> 실제로 서버를 프로그래밍할 때 인증과 인가를 어떻게 할지가 중요한 이슈

서버는 동시다발적으로 들어오는 무수한 요청에 응답하고 있는데 각 요청이 들어올 때마다 요청을 보낸 사용자가 인증과정을 거친 상태인지 확인을 해서 그에 따라 로그인이 필요한 기능들에 허용을 해줄지 말지를 결정해서 응답해야한다.

<br />

#### `cf) 아이디, 비밀번호를 브라우저에 저장해두고 매 요청마다 다시 로그인을 하면 어떨까?`

- 로그인은 생각보다 무거운 작업이다.

  1. 데이터베이스에 저장된 사용자 계정의 해시값 등을 꺼내온다
  2. 사용자의 암호를 복잡한 알고리즘으로 계산한 값과 일치하는지 확인

  => 계산도 힘들고 데이터베이스에 접근하는 것 자체가 시간과 자원을 많이 잡아먹는 일

- 요청마다 아이디와 패스워드가 전송된다면 보안상에도 좋지않다.

<br />

### 2.1. 세션

- 전통적으로 많이 사용되어온 방식
- 사용자가 로그인에 성공하면 서버는 세션을 출력해서 반쪽을 브라우저에 보내고 다른 반쪽은 서버의 메모리에 보관한다. (경우에 따라 하드디스크, 데이터베이스에 보관) (메모리 > 하드디스크 > 데이터베이스 순으로 속도가 빠르다.)
- 브라우저는 서버로 전달받은 세션을 `Session ID`란 이름으로 쿠키에 저장하고 다음 요청을 보낼 때 마다 세션을 같이 전달한다.
- 서버는 요청과 함께 온 세션을 자신이 가지고 있는 세션과 짝이 맞는지 확인해서 인가를 해준다.
- 세션: Session ID를 이용해서 사용자의 서버 로그인이 지속되는 상태
  -> 서버에서 어떤 사용자들이 현재 로그인해있는지를 세션을 통해 기억해두고 있는것
- 단점: 사용자가 동시에 많이 접속하면 메모리가 부족해진다.
  문제가 생겨서 서버가 재부팅된다면 메모리는 초기화된다.
  사용자는 로그인상태가 풀리게 되고 다시 로그인해야한다.
  하드디스크다 데이터베이스에 보관하게되면 속도가 느리다.
  서버를 여러대 두고 사이트를 운영할 때 문제가 생긴다.
  - 서버는 각자 메모리를 가지고 있어서 로드밸런싱 기능으로 사용자의 요청을 분산시키는데 인증은 1번 서버에서 기능 요청은 3번 서버에서 한다면 세션을 유지하기가 까다로워진다.
    (데이터베이스 서버를 활용하거나(속도 느림), 레디스나 MemCached 같은 메모리형 데이터베이스 서버(공용 메모리)에 세션을 보관하기도 한다. 공용 메모리도 문제가 발생할 수 있다.)
    => 서버가 복잡한 구성과 환경에서 어떤 상태를 기억해야된다는 것은 설계하기가 까다롭다.

### 2.2. 토큰 방식 JWT(JSON Web Token)

- 세션으로 하던 인가방식을 부담없이 구현하기 위해 고안됐다.
- 사용자가 로그인을 하면 토큰을 브라우저에 전달한다.(세션과 달리 서버에서는 토큰에 대한 정보를 아무것도 가지고 있지 않음)
- 인코딩(암호화)된 3가지 데이터를 이어붙인 형태
- 마침표를 기준으로 세 부분으로 나뉘는데 각각 header, payload, verify signature로 구분된다.

  - Base64로 디코딩
  - payload: 토큰을 누가 누구에게 발급했는지, 토큰이 언제까지 유효한지, 서비스가 사용자에게 토큰을 통해 공개하기 원하는 내용(닉네임, 서비스상의 레벨, 관리자 여부 등)을 서비스 측에서 원하는 대로 담을 수 있다. -> 이렇게 토큰에 담긴 사용자 정보 등의 데이터를 Claim이라고 한다.

    - 이후 요청에 토큰은 서버로 보내지게되고 토큰의 Claim 정보들은 서버가 요청마다 일일이 데이터베이스에서 고려해야할 것들이 줄어든다.

  - 특별한 암호화 없이 Base64로 인코딩돼있다는 것은 다시 디코딩해서 볼 수 있다는 것 -> 조작이 가능함(토큰의 유효기간을 늘릴 수도 있고 관리자 여부를 수정할 수 있다.)
  - 이러한 문제 때문에 header와 verify signature가 존재한다.

  - header: 토큰의 타입(항상 JWT, 고정값), alg(알고리즘)
    - alg: verify signature 값을 만드는데 사용될 알고리즘 (HS256 등 여러 암호화 방식이 있다.)
    - header, payload, '서버에 감춰져 있는 비밀 값' 이 셋을 alg에 넣고 암호화하면 verify signature가 생성된다.
    - 한쪽 방향으로는 계산이 되지만 반대쪽으로는 계산이 불가능 ('서버에 감춰져 있는 비밀 값'을 알 방법이 없다) => 조작 불가능
    - 서버는 요청에 토큰 값이 들어오면 header, payload, '서버의 비밀 키'와 함께 돌려봐서 계산된 결과값이 verify signature과 일치하는지 확인
    - 만약 payload가 조금이라도 수정됐다면 계산 결과가 달라지게된다
  - 서명갑과 계산값이 일치하고 유효기간이 지나지 않았다면 인가를 해준다.

=> 토큰을 사용하면 서버는 사용자들의 상태를 따로 기억하고 있을 필요가 없어진다.
stateless: 시간에 따라 바뀌는 어떤 상태값을 갖고 있지 않는 것 (토큰) <-> stateful (세션)

단점

- stateful해서 사용자들의 상태를 기억하고 있다는 건 구현하기 부담되고 고려사항도 많지만 기억하는 대상의 상태들을 언제든 제어할 수 있다는 것 (ex. 한 기기에만 로그인 가능한 서비스를 만드는 경우 새로운 로그인이 발생할 겨웅 기존 세션을 종료할 수 있다.)
- 토큰의 경우 이미 준 토큰을 뺐 수도 없고 토큰의 발급내역이나 정보를 따로 기록해서 추적하는 것이 아니기 때문에 통제는 불가능하다. -> 상태를 기억해두려고 하면 세션과 다를바가 없어짐
- 토큰이 탈취당한 경우 토큰을 무효화할 방법도 없다.

- 이러한 단점때문에 JWT만으로 인가를 구현해놓은 서비스는 많이 없다.

보완방법

- 만료시간을 가깝게 잡아서 토큰 수명을 짧게 줄인다. (로그인을 자주해야하는 불편함이 생김)
- 그래서 만료시간을 줄이는 대신 로큰을 두 개 발급한다.
  - access token: 수명이 몇 시간이나 몇 분 이하로 짧다. (수명이 짧은 인가 토큰)
  - refresh token: 보통 2주 정도로 비교적 긴 수명을 가진다. (access token을 재발급 받기위한 토큰)
- 구현 예시
  - refresh token의 상응 값은 데이터베이스에도 저장해놓는다.
  - 사용자는 access token의 수명이 다하면 refresh token을 서버에 보내고 서버는 데이터베이스에 저장된 값과 대조해보고 일치한다면 새로운 access token을 발급해준다.
  - refresh token만 안전하게 관리된다면 유효기간동안은 access token이 만료되더라도 다시 로그인할 필요가 없이 새롭게 access token을 발급받을 수 있다.
- access token이 탈취당하더라고 유효 기간이 짧아 오래 사용하지 못하게 된다.
- refresh token을 DB에서 지워서 토큰갱신을 막을 수도 있다.

- 한계점
  - access token이 살아있는 동안은 바로 차단할 방법이 없다.
  - 토큰 하나만 활용할 때 보다는 훨씬 낫지만 빈틈이 없지 않다.

=> JWT 방식이 편리하더라도 서비스에 적합한지 충분히 고려해야한다. (서비스에서 큰 이슈가 되지 않는 다면 정말 편리하고 경제적인 인가 방식)
