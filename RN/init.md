# React Native 처음 설치시 있는 요소들 정리

<br />

## 1. SafeAreaView (iOS Component)

- `SafeAreaView`는 디바이스의 안전 영역 안에 콘텐츠를 렌더링하는 역할을 한다. (iOS 11 버전 이상에만 적용)

- `SafeAreaView`는 네비게이션, 탭, 툴바 등과 같은 요소들이 안전한 영역에 배치될 수 있게 자동으로 패딩을 적용하여 중첩된 콘텐츠를 렌더링한다. `SafeAreaView`의 패딩은 둥근 모서리나 카메라 노치와 같은 화면의 물리적 제한도 반영한다.

- 사용할때 `flex: 1` 스타일을 적용한 `SafeAreaView`로 최상위 view를 감싸준다. 앱 디자인과 일치하는 배경색을 적용하는데 용의하다.

구성 요소의 동작을 구현하기 위해 패딩을 사용하므로 SafeAreaView에 적용된 스타일의 패딩 규칙은 무시되며 플랫폼에 따라 다른 결과를 초래할 수 있습니다. 자세한 내용은 #22211을 참조하십시오.

> 패딩은 이미 기본 동작을 구현하는 데 사용되어 있어 `SafeAreaView`에 직접 적용한 패딩은 무시된다. ([#22211](https://github.com/facebook/react-native/issues/22211))

<br />

## 2. ScrollView

- 각 플랫폼에서 제공하는 ScrollView를 감싸면서 해당 스크롤 기능을 사용한다. 터치 잠금 "응답자(responder)" 시스템과 통합되어 있어 사용자의 터치 입력을 적절히 처리한다.

> 터치 이벤트를 받아들이는 과정을 '응답자(responder) 시스템'이라고 부른다. 즉, 사용자의 터치 입력에 어떻게 반응할지를 관리하는 시스템을 의미한다.

- `ScrollView`는 제한된 높이(bound height)를 가져야 정상적으로 동작한다. 제한되지 않은 높이(unbounded-height)를 가진 내부의 자식 요소들이 들어가는 `ScrollView`는 제한된 높이를 가져야 한다. ScrollView의 높이를 제한하려면, 뷰의 높이를 직접 설정하는 방법(비권장)이나 모든 상위 뷰가 제한된 높이를 가지도록 해야 한다. 상위 뷰에 `{flex: 1}`을 설정하지 않았을 때는 공간이 충분하지 않은 문제가 발생할 수 있다. 앞서 말한 문제들은 요소 검사기를 통해 각 뷰의 실제 크기와 flex 설정 등을 확인하면서 어디서 문제가 발생했는지 파악할 수 있다.

- 현재 다른 터치 응답자가 ScrollView의 응답자가 되는 경우가 있다. (ScrollView 안에 Button을 터치 했는데 스크롤 터치로 반응)

> 응답자(responder)는 터치 이벤트에 반응하는 요소

- `contentInsetAdjustmentBehavior` (iOS 11 이상)

  - `ScrollView`의 콘텐츠 영역이 이 `SafeAreaView`과 어떻게 상호작용할지를 결정한다. 즉, 스크롤할 수 있는 콘텐츠가 안전 영역에서 어떻게 조정될지를 설정하는 것이다.

  - 옵션 (Default: `never`)

    - `automatic`: 시스템이 안전 영역에 맞게 자동으로 콘텐츠 인셋을 조정한다. ScrollView의 콘텐츠가 어느 축(축 또는 스크롤 가능한 축)에서든 안전 영역을 침범하면, 그에 따라 콘텐츠 인셋이 자동으로 조정된다.

    - `scrollableAxes`: 스크롤 가능한 축에 대해서만 안전 영역을 적용한다. 수직 스크롤이 가능한 경우, 위아래의 안전 영역을 고려해 조정하고, 수평 스크롤이 가능한 경우 양쪽의 안전 영역을 고려해 조정한다.

    - `never`: 안전 영역을 전혀 고려하지 않습니다. 이 경우, `ScrollView`의 콘텐츠는 안전 영역에 의해 가려질 수 있습니다. 이 옵션을 사용하면, 콘텐츠가 화면 상단이나 하단의 안전 영역에 의해 잘리더라도 조정되지 않는다.

    - `always`: 스크롤 가능한 축과 상관없이 항상 안전 영역을 고려하여 콘텐츠 인셋을 조정한다. 이 옵션을 선택하면, ScrollView가 스크롤 가능한지 여부와 관계없이 콘텐츠는 안전 영역에 맞게 조정된다.

### <ScrollView> vs <FlatList> - 어느 것을 사용할까?

- ScrollView는 모든 자식 컴포넌트를 한 번에 렌더링한다. 이는 성능상의 단점이 있다.

  - 예를 들어, 매우 긴 목록을 표시해야 하는 상황이 있다. 이 때 모든 내용을 한 번에 렌더링하면, 실제로 화면에 표시되지 않는 많은 요소들까지 렌더링하면서 렌더링 속도가 느려지고 메모리 사용량이 증가하게 된다.

- 위와 같은 상황에서 FlatList가 유용하다. FlatList는 항목들이 화면에 나타나기 직전에 렌더링하고, 화면에서 멀리 벗어난 항목들은 메모리와 처리 시간을 절약하기 위해 제거한다.

- FlatList는 항목들 사이에 구분선을 렌더링하거나, 여러 열을 표시하거나, 무한 스크롤 로딩 같은 다양한 기능을 기본적으로 지원하기 때문에 매우 유용하다.

<br />

## 3. useColorScheme

- `Appearance` 모듈에서 색 스키마를 제공하고 구독한다. 현재 사용자가 설정한 색 스키마를 반환한다. 사용자가 직접 장치 설정에서 테마 선택 하거나 일정(낮/밤 주기)에 따라 값이 업데이트될 수 있다.

> `Appearance` 모듈은 사용자가 설정한 색 스키마(light or dark)와 같은 사용자의 appearance 설정에 대한 정보를 가지고 있다.

> 현재 기술적 제약으로 Chrome 디버거가 활성화되면 항상 `"light"`를 반환한다.

- 지원하는 색 스키마
  - `"light"`: 사용자가 밝은 색상 테마를 설정
  - `"dark"`: 사용자가 어두운 색상 테마를 설정
  - `null`: 사용자가 선호하는 색상 테마를 지정하지 않았는 경우
